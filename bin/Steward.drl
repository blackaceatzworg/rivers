#created on: Mar 18, 2008

package rhein


import rhein.AddRetentionBasin;
import rhein.FloodProtection;
import rhein.RaiseDike;
import rhein.RetentionBasin;
import rhein.Segment;
import rhein.Steward;

/*
- für jeden steward:
	- mögliche aktionen generieren
		- immer oder nur bei bedarf?
	- normen anwenden
		- was ist mit konfligierenden normen?
	- wenn kein bedarf besteht, aktionen abbrechen
	- was passiert, wenn ich bedarf aber keine aktion habe?
		- wenn man jemanden direkt stromaufwärts kennt, kann man dem eine aktion hinterlegen
- und nocheinmal für jeden:
	- welche aktion nehmen?
		- die teuerste von jemanden anderen
		- die effektivste für mich
*/


query "all floodprotections"
    floodprotection : FloodProtection( )
end


//
//
// ACTION GENERATION
//
//


rule "Action Generation: raise dike"
		ruleflow-group "action_generation"
	when
		$me: Steward( )
		$segment: Segment( threatened == true , dikeCapacity < maxDikeCapacity )
	then
		int diff = (int)($segment.getMaxDikeCapacity() - $segment.getDikeCapacity());
		RaiseDike dike = new RaiseDike($segment, $me, Math.min(1000, diff));
		insert(dike);
		System.out.format("  >>> dike generated %s\n", dike);
end


rule "Action Generation: retention basin"
		ruleflow-group "action_generation"
	when
		$me: Steward( )
		$segment: Segment( threatened == true, naturalDike == false )
		$retention: RetentionBasin( ) from $segment.possibleRetentionBasins
	then
		AddRetentionBasin action = new AddRetentionBasin($segment, $me, $retention);
		insert(action);
		System.out.format("  >>> retention generated %s\n", action);
end

/**/
rule "Action Generation: no floodprotection yet but in need"
		salience -1
		ruleflow-group "action_generation"
	when
		$me: Steward( )
		$segment: Segment( threatened == true )
		not (exists  FloodProtection( segment == $segment ))
	then
		Segment upstream = $segment.getUpstreamRetentionBasins();
		if (upstream != null) {
			for (RetentionBasin retention : upstream.getPossibleRetentionBasins()) {
				AddRetentionBasin action = new AddRetentionBasin(upstream, $me, retention);
				insert(action);
				System.out.format("  >>> upstream (%s) retention generated %s for %s \n",
							      upstream.getName(), action, $segment.getName());
			}
		}
		else {
			System.out.format("  >>> no upstream retention found for %s \n",
						      $segment.getName());
		}
end
/**/

//
//
// NORMS
//
//


/**
rule "Norm: Don’t raise dikes"
	// Agents must not choose a RaiseDike Action.
	when
		$raise: RaiseDike( )
	then
		System.out.format("  >>> no dikes, retracted %s\n", $raise);
		retract($raise);
end
/**/


rule "Norm: Don’t build own flood protection in not threatened segments"
	// Agents must not choose a Floodprotection Action for a RiverSegment that is not threatened.
		ruleflow-group "norms"
	when
		$me: Steward( )
		$raise: FloodProtection( segment.steward == $me,
								 segment.threatened == false)
	then
		retract($raise);
		System.out.format("  >>> no overflow, retracted %s\n", $raise);
end


// Don’t decide measures which cost more than you can afford
//    Agents must not choose an Action which costs more than their accumulated
//    resources minus obligatory payment for already chosen actions.
rule "Norm: Don’t decide measures which cost more than you can afford"
    // TODO und wie stell ich sicher, dass ich nur eine Aktion mache und die dann auch bezahlen kann?
		ruleflow-group "norms"
	when
		$floodprotection: FloodProtection( payer.balance < cost )
	then
		System.out.format("  >>> not enough funds to pay for %s\n", $floodprotection);
		retract($floodprotection);
end



//
//
// CHOSING
//
//


rule "insert floodprotections"
		ruleflow-group "action_selection"
		salience 10
	when
		$me: Steward(  )
		$segment: Segment( )
		$f: FloodProtection(  ) from $segment.possibleActions
	then
		insert($f);
		System.out.format("  >>> inserted %s\n", $f);
end


rule "remove own floodprotections if someone else wants one"
		ruleflow-group "action_selection"
		salience 5
	when
		$me: Steward(  )
		$segment: Segment(  )
		exists FloodProtection( payer != $me, segment == $segment )
		$f: FloodProtection( segment == $segment, payer == $me )
	then
		retract($f);
		System.out.format("  >>> retracted own %s\n", $f);
end


/*
rule "choose floodprotection"
		ruleflow-group "action_selection"
		salience 0
	when
		$segment: Segment(  )
		// TODO using hashCode is a hack, isn't it?
		$f1: FloodProtection( segment == $segment, $efficiency: costEffectiveness, $hashCode: hashCode  )
		$f2: FloodProtection( segment == $segment, costEffectiveness <= $efficiency, hashCode != $hashCode  )
	then
		$segment.removePossibleAction($f2);
		System.out.format("  >>> retracted inferior %s\n", $f2);
		retract($f2);
end
/**/

rule "choose floodprotection"
		ruleflow-group "action_selection"
		salience 0
	when
		$segment: Segment(  )
		// TODO using hashCode is a hack, isn't it?
		$f1: FloodProtection( segment == $segment, $efficiency: wholeBasinCostEffectiveness, $hashCode: hashCode  )
		$f2: FloodProtection( segment == $segment, wholeBasinCostEffectiveness <= $efficiency, hashCode != $hashCode  )
	then
		$segment.removePossibleAction($f2);
		System.out.format("  >>> retracted inferior %s\n", $f2);
		retract($f2);
end
/**/